<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Color Pop Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            flex-direction: column; /* To stack button and canvas */
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            font-family: 'Arial Rounded MT Bold', 'Helvetica Rounded', Arial, sans-serif;
            touch-action: none; /* Prevent default touch behaviors like scrolling/zooming */
        }
        #gameContainer {
            position: relative; /* For positioning button over canvas if needed */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameCanvas {
            border: 2px solid #333;
            background-color: #fff;
            cursor: pointer;
            /* Max width/height will be controlled by JS now for better fullscreen transition */
        }
        #fullscreenButton {
            position: fixed; /* Fixed position relative to viewport */
            bottom: 10px;
            right: 10px;
            padding: 10px 15px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1000; /* Ensure it's on top */
        }
        #fullscreenButton:hover {
            background-color: #45a049;
        }

        /* Styles when in fullscreen to hide scrollbars and ensure body fills screen */
        :fullscreen, :webkitIsFullScreen, :mozFullScreen {
            overflow: hidden !important; /* Important to override any body overflow */
        }
        body:fullscreen, body:-webkit-full-screen, body:-moz-full-screen {
            width: 100%;
            height: 100%;
            /* Ensure no margins or padding interfere */
            margin: 0;
            padding: 0;
        }

    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <button id="fullscreenButton">Fullscreen</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const fullscreenButton = document.getElementById('fullscreenButton');
        const gameContainer = document.getElementById('gameContainer'); // Will be our fullscreen target

        // --- Game Configuration ---
        const GAME_COLORS = ['red', 'green', 'yellow', 'blue', 'purple', 'orange', 'pink', 'brown'];
        const BUBBLE_RADIUS_MIN = 35;
        const BUBBLE_RADIUS_MAX = 60;
        const NUM_BUBBLES_MIN = 4;
        const NUM_BUBBLES_MAX = 7;
        const BUBBLE_SPEED_MAX = 0.8;
        const BUBBLE_OPACITY = 0.75;
        const PARTICLE_COUNT = 25;
        const PARTICLE_SPEED = 2.5;
        const PARTICLE_LIFE = 70;
        const CONFETTI_COUNT = 180;
        const CONFETTI_LIFE = 150;

        // --- Game State ---
        let currentColorIndex = 0;
        let currentWord = '';
        let bubbles = [];
        let particles = [];
        let confetti = [];
        let wrongBalloons = [];
        let level = 0;
        let celebrationTimeout = null;
        let isCelebrating = false;

        // --- Utility Functions ---
        function getRandom(min, max) {
            return Math.random() * (max - min) + min;
        }

        function setCanvasSize() {
            const isFullScreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
            let parentWidth, parentHeight;

            if (isFullScreen) {
                parentWidth = window.innerWidth; // Use full screen dimensions
                parentHeight = window.innerHeight;
            } else {
                parentWidth = window.innerWidth * 0.95; // Use viewport dimensions with some padding
                parentHeight = window.innerHeight * 0.95;
            }

            const maxWidth = 1000; // Max dimensions for non-fullscreen
            const maxHeight = 750;
            let aspectRatio = 4/3; // Desired aspect ratio

            let w = parentWidth;
            let h = parentHeight;

            if (w / h > aspectRatio) {
                w = h * aspectRatio;
            } else {
                h = w / aspectRatio;
            }

            if (!isFullScreen) {
                canvas.width = Math.min(w, maxWidth);
                canvas.height = Math.min(h, maxHeight);
            } else {
                canvas.width = w; // Use full available space in fullscreen
                canvas.height = h;
            }
            
            // Center the gameContainer if canvas is smaller than window (non-fullscreen)
            if (!isFullScreen) {
                gameContainer.style.width = `${canvas.width}px`;
                gameContainer.style.height = `${canvas.height}px`;
            } else {
                gameContainer.style.width = `100%`;
                gameContainer.style.height = `100%`;
            }


            // Redraw if game is active
            if (!isCelebrating && currentWord) {
                 draw(); // Redraw the current state
            } else if (isCelebrating) {
                draw(); // Also redraw during celebration
            }
        }

        // --- Fullscreen API Handling ---
        function toggleFullScreen() {
            const elem = document.documentElement; // Make the whole page fullscreen

            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => {
                        // alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                        console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                    });
                } else if (elem.mozRequestFullScreen) { /* Firefox */
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                    elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                } else if (elem.msRequestFullscreen) { /* IE/Edge */
                    elem.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE/Edge */
                    document.msExitFullscreen();
                }
            }
        }

        function updateFullscreenButton() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                fullscreenButton.textContent = 'Exit Fullscreen';
            } else {
                fullscreenButton.textContent = 'Fullscreen';
            }
        }

        fullscreenButton.addEventListener('click', toggleFullScreen);
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
        document.addEventListener('mozfullscreenchange', updateFullscreenButton);
        document.addEventListener('MSFullscreenChange', updateFullscreenButton);


        // --- Bubble Class ---
        class Bubble {
            constructor(x, y, radius, color, isWrong = false) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.dx = getRandom(-BUBBLE_SPEED_MAX, BUBBLE_SPEED_MAX) || 0.05 * (Math.random() < 0.5 ? 1 : -1) ;
                this.dy = getRandom(-BUBBLE_SPEED_MAX, BUBBLE_SPEED_MAX) || 0.05 * (Math.random() < 0.5 ? 1 : -1) ;
                this.opacity = BUBBLE_OPACITY;
                this.isPopped = false;
                this.isWrong = isWrong;
            }

            draw() {
                if (this.isPopped) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.opacity;
                ctx.fill();
                ctx.globalAlpha = 1.0;

                ctx.beginPath();
                ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.25, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();
            }

            update() {
                if (this.isPopped) return;

                this.x += this.dx;
                this.y += this.dy;

                if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
                    this.dx *= -1;
                    this.x = Math.max(this.radius, Math.min(this.x, canvas.width - this.radius));
                }
                if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {
                    this.dy *= -1;
                    this.y = Math.max(this.radius, Math.min(this.y, canvas.height - this.radius));
                }
            }

            pop() {
                if (this.isWrong) return false;
                if (this.isPopped) return false;

                this.isPopped = true;
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    particles.push(new Particle(this.x, this.y, this.color, this.radius * 0.3));
                }
                return true;
            }
        }

        // --- Particle Class ---
        class Particle {
            constructor(x, y, color, initialSize) {
                this.x = x;
                this.y = y;
                this.radius = getRandom(initialSize * 0.2, initialSize * 0.5);
                this.color = color;
                this.dx = getRandom(-PARTICLE_SPEED, PARTICLE_SPEED);
                this.dy = getRandom(-PARTICLE_SPEED, PARTICLE_SPEED);
                this.life = PARTICLE_LIFE;
                this.opacity = 1;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.opacity;
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.dy += 0.03;
                this.life--;
                this.opacity = Math.max(0, this.life / PARTICLE_LIFE);
                if (this.radius > 0.2) this.radius -= 0.05;
            }
        }

        // --- Confetti Particle Class ---
        class ConfettiParticle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height - canvas.height;
                this.size = getRandom(8, 20);
                this.color = `hsl(${Math.random() * 360}, 100%, 75%)`;
                this.dx = getRandom(-2.5, 2.5);
                this.dy = getRandom(1.5, 4.5);
                this.life = CONFETTI_LIFE;
                this.opacity = 1;
                this.angle = Math.random() * Math.PI * 2;
                this.spin = getRandom(-0.15, 0.15);
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.opacity;
                const shapeType = Math.floor(Math.random() * 3);
                if (shapeType === 0) {
                    ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size * 0.6);
                } else if (shapeType === 1) {
                    ctx.beginPath();
                    ctx.arc(0,0, this.size/2, 0, Math.PI*2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size / 2);
                    ctx.lineTo(this.size / 2, this.size / 2);
                    ctx.lineTo(-this.size / 2, this.size / 2);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.restore();
                ctx.globalAlpha = 1.0;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                this.angle += this.spin;
                this.life--;
                this.opacity = Math.max(0, this.life / CONFETTI_LIFE);
                if (this.dy < 6) this.dy += 0.06;
                if (this.dx > 0) this.dx -= 0.015; else if (this.dx < 0) this.dx += 0.015;

                if (this.y > canvas.height + this.size && this.dy > 0 && this.life > CONFETTI_LIFE * 0.2) {
                    this.y = canvas.height + this.size;
                    this.dy *= -0.6;
                }
                if (this.x < -this.size) this.x = canvas.width + this.size;
                if (this.x > canvas.width + this.size) this.x = -this.size;
            }
        }

        // --- Game Logic ---
        function startNextLevel() {
            level++;
            currentWord = GAME_COLORS[currentColorIndex];
            bubbles = [];
            wrongBalloons = [];
            particles = [];
            confetti = [];
            isCelebrating = false;
            clearTimeout(celebrationTimeout);
            // Make sure canvas is sized correctly for the new level
            setCanvasSize(); // Call this to ensure canvas is ready before drawing bubbles

            const numBubbles = Math.floor(getRandom(NUM_BUBBLES_MIN, NUM_BUBBLES_MAX + 1));
            for (let i = 0; i < numBubbles; i++) {
                let radius, x, y, validPosition;
                let attempts = 0; // Prevent infinite loop
                do {
                    validPosition = true;
                    radius = getRandom(BUBBLE_RADIUS_MIN * (canvas.width/800), BUBBLE_RADIUS_MAX * (canvas.width/800)); // Scale radius
                    radius = Math.max(20, radius); // Minimum radius
                    x = getRandom(radius, canvas.width - radius);
                    y = getRandom(radius, canvas.height - radius);
                    for(const b of bubbles) {
                        const dist = Math.sqrt((x-b.x)**2 + (y-b.y)**2);
                        if(dist < radius + b.radius + 10) {
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                } while(!validPosition && attempts < 50); // Try 50 times
                if (validPosition) { // Only push if a valid position was found
                    bubbles.push(new Bubble(x, y, radius, currentWord));
                }
            }

            if (level > 2) {
                const numWrongBalloons = Math.floor(getRandom(1, level > 4 ? 3 : 2));
                for (let i = 0; i < numWrongBalloons; i++) {
                    let wrongColor = currentWord;
                    while (wrongColor === currentWord) {
                        wrongColor = GAME_COLORS[Math.floor(Math.random() * GAME_COLORS.length)];
                    }
                     let radius, x, y, validPosition;
                     let attempts = 0;
                    do {
                        validPosition = true;
                        radius = getRandom(BUBBLE_RADIUS_MIN * (canvas.width/800), BUBBLE_RADIUS_MAX * (canvas.width/800));
                        radius = Math.max(20, radius);
                        x = getRandom(radius, canvas.width - radius);
                        y = getRandom(radius, canvas.height - radius);
                        for(const b of [...bubbles, ...wrongBalloons]) {
                            const dist = Math.sqrt((x-b.x)**2 + (y-b.y)**2);
                            if(dist < radius + b.radius + 10) {
                                validPosition = false;
                                break;
                            }
                        }
                        attempts++;
                    } while(!validPosition && attempts < 50);
                    if(validPosition) {
                        wrongBalloons.push(new Bubble(x, y, radius, wrongColor, true));
                    }
                }
            }

            currentColorIndex = (currentColorIndex + 1) % GAME_COLORS.length;
            if (currentColorIndex === 0 && level > GAME_COLORS.length) {
                shuffleArray(GAME_COLORS);
            }
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }


        function drawWord() {
            ctx.fillStyle = currentWord;
            ctx.strokeStyle = 'black';
            ctx.lineWidth = Math.max(2, canvas.width * 0.005); // Scale line width
            const baseFontSize = Math.min(canvas.width / (currentWord.length * 0.8 + 2), canvas.height * 0.15);
            const fontSize = Math.max(24, baseFontSize); // Minimum font size
            ctx.font = `bold ${fontSize}px 'Arial Rounded MT Bold', 'Helvetica Rounded', Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.strokeText(currentWord.toUpperCase(), canvas.width / 2, canvas.height / 2);
            ctx.fillText(currentWord.toUpperCase(), canvas.width / 2, canvas.height / 2);
        }

        function handleInteraction(event) {
            if (isCelebrating) return;

            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (event.type.startsWith('mouse')) {
                clientX = event.clientX;
                clientY = event.clientY;
            } else if (event.type.startsWith('touch')) {
                if (event.touches.length === 0) return;
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
                event.preventDefault();
            } else {
                return;
            }

            const x = (clientX - rect.left) * (canvas.width / rect.width); // Scale click to canvas internal resolution
            const y = (clientY - rect.top) * (canvas.height / rect.height);


            for (let i = bubbles.length - 1; i >= 0; i--) {
                const bubble = bubbles[i];
                if (bubble.isPopped) continue;
                const distance = Math.sqrt((x - bubble.x) ** 2 + (y - bubble.y) ** 2);
                if (distance < bubble.radius) {
                    if (bubble.pop()) {
                        return;
                    }
                }
            }
            for (let i = wrongBalloons.length - 1; i >= 0; i--) {
                const balloon = wrongBalloons[i];
                const distance = Math.sqrt((x - balloon.x) ** 2 + (y - balloon.y) ** 2);
                if (distance < balloon.radius) {
                    return;
                }
            }
        }


        function update() {
            if (isCelebrating) {
                confetti.forEach(c => c.update());
                confetti = confetti.filter(c => c.life > 0 || c.y < canvas.height + c.size * 2);
                return;
            }

            [...bubbles, ...wrongBalloons].forEach(b => b.update());
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0 && p.radius > 0);

            const activeBubbles = bubbles.filter(b => !b.isPopped);
            if (activeBubbles.length === 0 && bubbles.length > 0 && !isCelebrating) {
                isCelebrating = true;
                for (let i = 0; i < CONFETTI_COUNT; i++) {
                    confetti.push(new ConfettiParticle());
                }
                const celebrationDuration = (CONFETTI_LIFE * (1000 / 60)) * 1.2 + 500;
                celebrationTimeout = setTimeout(() => {
                    celebrationTimeout = null;
                    if (isCelebrating) {
                       startNextLevel();
                    }
                }, celebrationDuration);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (isCelebrating) {
                const fontSize = Math.max(30, canvas.height * 0.2);
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.font = `bold ${fontSize}px 'Arial Rounded MT Bold'`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("YAY!", canvas.width / 2, canvas.height / 2);
                confetti.forEach(c => c.draw());
            } else {
                if (currentWord) { // Only draw word if it's set
                   drawWord();
                }
                wrongBalloons.forEach(b => b.draw());
                bubbles.forEach(b => b.draw());
                particles.forEach(p => p.draw());
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function init() {
            setCanvasSize(); // Initial sizing
            shuffleArray(GAME_COLORS);
            
            window.addEventListener('resize', () => {
                setCanvasSize(); // This will be called on fullscreen change too
            });

            canvas.addEventListener('mousedown', handleInteraction);
            canvas.addEventListener('touchstart', handleInteraction, { passive: false });

            startNextLevel();
            gameLoop();
        }

        init();
    </script>
</body>
</html>
